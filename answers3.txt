1. В чем разница между селектором по классу и по ID с точки зрения специфичности и возможности повторного использования?

Специфичность: ID селектор (#id) имеет гораздо более высокую специфичность, чем класс (.class). Если к одному элементу применить и стиль по классу, и по ID, то «перевесит» стиль от ID.
Повторное использование: Классы предназначены для многократного использования на множестве элементов на странице. ID должен быть уникальным в пределах страницы, то есть применяться только к одному элементу. Поэтому классы используются для стилизации однотипных компонентов (например, кнопок, карточек), а ID — для стилизации уникальных элементов (например, шапки, основного меню, модального окна).


2. Как работает каскад в CSS и в каком порядке применяются стили при конфликте правил?

Каскад — это механизм, который определяет, какие именно стили будут применены к элементу, когда на него влияет несколько правил. Порядок разрешения конфликтов (от низшего приоритета к высшему):
Источник и важность: Сначала проверяется, объявлено ли правило с !important. Затем смотрят на его происхождение (пользовательские стили, авторские и т.д.).
Специфичность селектора: Если важность одинакова, «побеждает» стиль с более специфичным селектором. Например, ID > Класс > Тег.
Порядок в коде: Если все предыдущие параметры равны, браузер применяет то правило, которое было объявлено в коде последним.


3. Рассчитайте специфичность для селекторов:

Формула специфичности: (a, b, c), где:
a = количество ID селекторов
b = количество классов, псевдоклассов, атрибутов
c = количество тегов, псевдоэлементов
ul li.important
Теги: ul, li → 2
Класс: .important → 1
Итог: (0, 1, 2)
#site-title
ID: #site-title → 1
Итог: (1, 0, 0)
.content > .featured-post
Классы: .content, .featured-post → 2
Итог: (0, 2, 0) (дочерний комбинатор > не влияет на специфичность)


4. Какие свойства в CSS наследуются по умолчанию, а какие нет? Приведите по 3 примера каждого типа.

Наследуются (дочерние элементы получают эти стили от родителя):
color
font-family, font-size
line-height, text-align
Не наследуются (стиль применяется только к самому элементу, его дети остаются без изменений):
width, height
margin, padding, border
background


5. Как работает селектор > (дочерний селектор) и чем он отличается от селектора потомков (через пробел)?

Дочерний селектор (A > B): Выбирает только те элементы B, которые являются непосредственными (прямыми) детьми элемента A.
Селектор потомков (A B): Выбирает все элементы B, которые находятся внутри A, на любом уровне вложенности.


6. Для чего используются псевдоклассы :hover и :nth-child()? В каких практических задачах они могут пригодиться?

:hover: Срабатывает, когда пользователь наводит курсор на элемент.
Задачи: создание интерактивных кнопок (смена цвета, тени), всплывающих подсказок, изменение ссылок при наведении.
:nth-child(): Позволяет выбирать элементы на основе их порядкового номера внутри родителя.
Задачи: покраска строк таблицы в зебру (tr:nth-child(even)), выделение каждого третьего элемента в сетке, стилизация первого/последнего элемента списка особым образом.


7. Что делает правило !important и почему его следует использовать с осторожностью?

!important объявляет стиль как «самый важный». Он переопределяет все другие факторы каскада, включая специфичность и порядок.
Почему его используют осторожно:
Ломает каскад: Он нарушает естественный порядок CSS, из-за чего становится сложно предсказать, какой стиль в итоге применится.
Проблемы с поддержкой: Если в проекте много !important, чтобы переопределить один из них, придется писать еще один !important. Это приводит к «войне важности» и сильно усложняет поддержку кода.
Использовать стоит только в крайних случаях, например, для переопределения стилей из сторонней библиотеки, которые вы не можете легко изменить.


8. Как псевдоэлементы ::before и ::after расширяют возможности CSS и какой контент они могут содержать?

Они позволяют добавить два дополнительных «виртуальных» элемента внутрь выбранного тега (до и после его основного содержимого). Это расширяет возможности верстки без лишнего «мусора» в HTML.
Какой контент они могут содержать:
Текст (через свойство content: "текст").
Иконки (например, через content: "\1F609").
Пустое пространство (для декоративных фигур через content: "").
Изображения (через background-image).
Практическое применение: декоративные линии, иконки перед ссылками, красивые кавычки для цитат, оверлеи для картинок, нумерация.


9. В каком порядке браузер применяет CSS-правила при одинаковой специфичности селекторов?

При одинаковой специфичности браузер применяет стили в соответствии с порядком в коде: правило, объявленное ниже в таблице стилей (или подключенное позже), имеет приоритет над тем, что объявлено выше.


10. Как инструменты разработчика в браузере помогают анализировать и отлаживать CSS-код?

Инструменты разработчика (F12) — это главный помощник верстальщика.
Инспектор элементов: Можно навести на любой элемент на странице и увидеть его HTML-структуру и все примененные к нему CSS-правила.
Панель Styles: Показывает все стили, влияющие на выбранный элемент, в порядке их каскада. Можно видеть, какие правила применены, а какие переопределены (зачеркнуты).
Live-редактирование: Позволяет прямо в браузере изменять CSS-свойства, добавлять новые или отключать существующие. Это позволяет мгновенно видеть результат и экспериментировать без изменения исходных файлов.
Расчет специфичности: Показывает, какие селекторы «победили» в каскаде.
Box Model: Наглядно отображает margin, padding, border и content элемента, помогая точно настроить отступы и размеры.